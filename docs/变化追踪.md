> [vue2 docs - 深入响应式原理](https://v2.cn.vuejs.org/v2/guide/reactivity.html)

> 当你把一个普通的 JavaScript 对象传入 Vue 实例作为 `data` 选项，Vue 将遍历此对象所有的 property，并使用 [`Object.defineProperty`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 把这些 property 全部转为 [getter/setter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#定义_getters_与_setters)。`Object.defineProperty` 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。

> 这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 [vue-devtools](https://github.com/vuejs/vue-devtools) 来获取对检查数据更加友好的用户界面。

> 每个组件实例都对应一个 **watcher** 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。

![data](./reactivity.png)

## 这里的 watcher 是什么？

> 渲染 watcher， 即触发 diff 更新的 render 函数

watcher 会设置一个全局变量，让全局变量记录当前负责执行的 watcher 等于自己，然后再去执行函数，在函数执行的过程中，如果发生了依赖记录 `dep.depend()`，那么 Dep 就会把这个全局变量记录下来，表示：有一个 watcher 用到了我这个属性。

每一个 vue 组件实例，都至少有一个与之对应的 watcher，该 watcher 中记录了该组件的 render 函数，其他的 watcher 对应一些自定义的函数（watch，computed，$watch）。

watcher 首先会把 render 函数执行一次以收集依赖，于是那些在 render 中用到的响应式数据就会记录这个 watcher。

当数据变化时，dep 就会通知 watcher，而 watcher 将重新运行 render 函数，从而让界面重新渲染同时重新收集依赖。

## 不同的 watcher 在 Scheduler 中如何执行

在一个 vue 实例中如果存在多个 watcher 函数，执行顺序是先执行其他 watcher ，最后执行 渲染 watcher。

调度器维护一个队列，该队列同一个 wacher 仅会存在一次，队列中的 watcher 不是立即执行，它会通过一个 nextTick 的工具方法，把这些需要执行的 watcher 放入到事件循环的微任务队列中，当执行栈空闲时执行 。
